# IFaceTableGen.py - regenerate the IFaceTable.cxx from the Scintilla.iface
# interface definition file.  Based on Scintilla's HFacer.py.
# The header files are copied to a temporary file apart from the section between a //++Autogenerated
# comment and a //--Autogenerated comment which is generated by the printHFile and printLexHFile
# functions. After the temporary file is created, it is copied back to the original file name.

import string
import sys
import os

srcRoot = "../.."

sys.path.append(srcRoot + "/scintilla/include")

import Face

def Contains(s,sub):
	return string.find(s, sub) != -1

def printIFaceTableCXXFile(f,out):
	constants = []
	functions = []
	
	for name in f.order:
		features = f.features[name]
		if features["Category"] != "Deprecated":
			if features["FeatureType"] == "val":
				if not (Contains(name, "SCE_") or Contains(name, "SCLEX_")):
					constants.append( (name, features["Value"]) )
			elif features["FeatureType"] in ["fun","get","set"]:
				functions.append((name, features))


	out.write("\nstatic IFaceConstant ifaceConstants[] = {")
	
	if constants:
		constants.sort()
		
		first = 1
		for name, value in constants:
			if first: first = 0
			else: out.write(",")
			
			out.write('\n\t{"%s",%s}' % (name, value))
		
		out.write("\n};\n")
	else:
		out.write('{"",0}};\n')

	# Write an array of function descriptions.  This can be
	# used as a sort of compiled typelib.

	out.write("\nstatic IFaceFunction ifaceFunctions[] = {")
	if functions:
		functions.sort()
	
		first = 1
		for name, features in functions:
			if first: first = 0
			else: out.write(",")
			
			paramTypes = [
				features["Param1Type"] or "void",
				features["Param2Type"] or "void"
			]
			
			# Fix-up: if a param is an int named length, change to iface_type_length.
			if features["Param1Type"] == "int" and features["Param1Name"] == "length":
				paramTypes[0] = "length"

			if features["Param2Type"] == "int" and features["Param2Name"] == "length":
				paramTypes[1] = "length"


			out.write('\n\t{"%s", %s, iface_%s, {iface_%s, iface_%s}}' % (
				name, features["Value"], features["ReturnType"] or "void", paramTypes[0], paramTypes[1]
			))
	
		out.write("\n};\n")
	
	else:
		out.write('{""}};\n')
	
	out.write("\nenum {\n")
	out.write("\tifaceFunctionCount = %d,\n" % len(functions))
	out.write("\tifaceConstantCount = %d\n" % len(constants))
	out.write("};\n\n")


def CopyWithInsertion(input, output, genfn, definition):
	copying = 1
	for line in input.readlines():
		if copying:
			output.write(line)
		if Contains(line, "//++Autogenerated"):
			copying = 0
			genfn(definition, output)
		if Contains(line, "//--Autogenerated"):
			copying = 1
			output.write(line)

def contents(filename):
	f = file(filename)
	t = f.read()
	f.close()
	return t

def Regenerate(filename, genfn, definition):
	inText = contents(filename)
	tempname = "IFaceTableGen.tmp"
	out = open(tempname,"w")
	hfile = open(filename)
	CopyWithInsertion(hfile, out, genfn, definition)
	out.close()
	hfile.close()
	outText = contents(tempname)
	if inText == outText:
		os.unlink(tempname)
	else:
		os.unlink(filename)
		os.rename(tempname, filename)

f = Face.Face()
f.ReadFromFile(srcRoot + "/scintilla/include/Scintilla.iface")
Regenerate(srcRoot + "/scite/src/IFaceTable.cxx", printIFaceTableCXXFile, f)
