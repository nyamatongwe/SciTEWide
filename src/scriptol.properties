
# Define SciTE settings for Scriptol SOL files.



file.patterns.sol=*.sol
filter.scriptol=scriptol (.sol)|$(file.patterns.sol)|
lexer.$(file.patterns.sol)=scriptol


keywordclass.scriptol= alias always and array as boolean break by byte case \
catch class constant \
continue define dict do dyn echo else enum error exception false file \ 
for forever function global gtk if import in include int integer is java \
javax let long match mod natural nil not null number or print protected  \
public real return scan script scriptol short sol static step super text this \
throw true try until using var void volatile while zero 


keywords.$(file.patterns.sol)=$(keywordclass.scriptol)


#comment.block.scriptol=//~
comment.block.scriptol=`~
#comment.block.at.line.start.scriptol=1
comment.stream.start.scriptol=/*
comment.stream.end.scriptol=*/
fold.comment=1

statement.indent.$(file.patterns.sol)=5 case match catch class do else for if \
scan try while
statement.end.$(file.patterns.sol)=10 ;
statement.lookback.$(file.patterns.sol)=20
#block.start.$(file.patterns.sol)=10 {
#block.end.$(file.patterns.sol)=10 /



# Scriptol styles

# Default
style.scriptol.0=fore:#808080
# Line comment
style.scriptol.1=$(colour.code.comment.line),$(font.code.comment.line)
# Number
style.scriptol.2=$(colour.number)
# Keyword
style.scriptol.3=$(colour.keyword),bold
# String
style.scriptol.4=$(colour.string),$(font.monospace)
# Character
style.scriptol.5=$(colour.char),$(font.monospace)
# Operators
style.scriptol.6=$(colour.operator),bold
# Identifier
style.scriptol.7=fore:#800000
# End of line where string is not closed
style.scriptol.8=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled

# Comment keyword
style.scriptol.17=fore:#3060A0,$(font.code.comment.doc)
style.scriptol.19=fore:#3060A0,$(font.code.comment.doc)

cc=solc -c $(FileNameExt) 

command.compile.*.sol=$(cc)
command.build.*.sol=solc -b -e $(FileNameExt)
command.go.*.sol=$(FileName)


